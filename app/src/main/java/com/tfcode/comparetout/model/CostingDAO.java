/*
 * Copyright (c) 2023-2024. Tony Finnerty
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.tfcode.comparetout.model;

import androidx.lifecycle.LiveData;
import androidx.room.Dao;
import androidx.room.Insert;
import androidx.room.Query;

import com.tfcode.comparetout.model.costings.Costings;

import java.util.List;

/**
 * Data Access Object for managing electricity cost calculations and comparisons.
 * 
 * This DAO handles the storage and retrieval of cost analysis results generated by
 * applying different price plans to energy usage scenarios. It provides methods for
 * finding optimal pricing strategies and maintaining data consistency as price plans
 * and scenarios change.
 * 
 * Key functionality:
 * - Store cost calculation results for scenario/price plan combinations
 * - Find best (lowest cost) pricing options for scenarios
 * - Export cost comparison data for analysis
 * - Maintain referential integrity with price plan deletions
 * - Check existence of calculations to avoid duplicate processing
 * 
 * Cost calculations include:
 * - Net cost (total cost after buy/sell transactions)
 * - Buy costs (electricity purchased from grid)
 * - Sell income (electricity sold to grid)
 * - Standing charges and signup bonuses
 */
@Dao
public abstract class CostingDAO {

    /**
     * Load all cost calculation results for reactive UI display.
     * @return LiveData list of all Costings records
     */
    @Query("SELECT * FROM costings")
    public abstract LiveData<List<Costings>> loadCostings();

    /**
     * Save a cost calculation result to the database.
     * @param costing The Costings record to insert
     */
    @Insert
    public abstract void saveCosting(Costings costing);

    /**
     * Delete all cost calculations associated with a specific price plan.
     * Called when a price plan is deleted to maintain referential integrity.
     * @param id The pricePlanID foreign key
     */
    @Query("DELETE FROM costings WHERE pricePlanID = :id")
    public abstract void deleteRelatedCostings(int id);

    /**
     * Find the most cost-effective price plan for a given scenario.
     * 
     * Query: SELECT * FROM costings 
     *        WHERE net = (SELECT MIN(net) FROM costings WHERE scenarioID = :scenarioID)
     *        AND scenarioID = :scenarioID
     * 
     * This query uses a subquery to find the minimum net cost for the scenario,
     * then returns the complete costing record that achieved that minimum.
     * The "net" field represents the total cost after accounting for both
     * electricity purchases and sales back to the grid.
     * 
     * @param scenarioID The scenario to find the best costing for
     * @return The Costings record with the lowest net cost for the scenario
     */
    @Query("SELECT * FROM costings " +
            "WHERE (net = (SELECT MIN(net) AS bignet FROM costings AS costings_1 WHERE scenarioID = :scenarioID))" +
            "AND scenarioID = :scenarioID")
    public abstract Costings getBestCostingForScenario(Long scenarioID);

    /**
     * Check if a cost calculation already exists for a scenario/price plan combination.
     * Used to avoid duplicate calculations and improve performance.
     * 
     * Query: SELECT EXISTS (SELECT * FROM costings WHERE scenarioID = :scenarioID AND pricePlanId = :pricePlanIndex)
     * 
     * @param scenarioID The scenario ID to check
     * @param pricePlanIndex The price plan ID to check
     * @return true if a costing record exists for this combination
     */
    @Query("SELECT EXISTS (SELECT * FROM costings WHERE scenarioID = :scenarioID AND pricePlanId = :pricePlanIndex) AS OK")
    public abstract boolean costingExists(long scenarioID, long pricePlanIndex);

    /**
     * Export all cost comparison data in CSV-ready format.
     * 
     * Query: SELECT DISTINCT REPLACE(scenarioName, ',', ';') || ', ' || fullPlanName || ', ' || 
     *               net || ', ' || buy || ', ' || sell || ', ' || standingCharges || ', ' || signUpBonus
     *        FROM costings, PricePlans WHERE pricePlanIndex = pricePlanID
     * 
     * This complex query:
     * 1. JOINs costings with PricePlans to get plan details
     * 2. Concatenates all relevant fields into a single CSV line
     * 3. Replaces commas in scenario names with semicolons to prevent CSV parsing issues
     * 4. Uses DISTINCT to avoid duplicate entries
     * 
     * The result format is: ScenarioName, PlanName, NetCost, BuyCost, SellIncome, StandingCharges, SignupBonus
     * 
     * @return List of CSV-formatted strings for export
     */
    @Query("SELECT DISTINCT REPLACE(scenarioName, ',', ';') || ', ' || fullPlanName || ', ' || net || ', ' || buy || ', ' || sell || ', ' || " +
            "standingCharges || ', ' || signUpBonus AS line FROM costings, PricePlans WHERE pricePlanIndex = pricePlanID")
    public abstract List<String> getAllComparisonsNow();

    /**
     * Remove orphaned cost calculations that reference deleted price plans.
     * 
     * Query: DELETE FROM costings WHERE pricePlanId NOT IN (SELECT pricePlanIndex FROM PricePlans)
     * 
     * This maintenance query removes any costing records that reference price plans
     * that have been deleted, ensuring referential integrity. The NOT IN subquery
     * identifies costings with foreign keys that no longer have corresponding
     * parent records in the PricePlans table.
     */
    @Query("DELETE FROM costings WHERE pricePlanId NOT IN (SELECT pricePlanIndex FROM PricePlans)")
    public abstract void pruneCostings();
}
